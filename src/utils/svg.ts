import * as fs from "fs";
import Handlebars from "handlebars";
import path from "path";

export type CompiledSvgTemplate = ReturnType<typeof compileSvg>;
export type Replacements = Record<string, unknown>;

/**
 * Takes a compiled SVG template, replaces the appropriate placeholders, and
 * returns the resulting SVG
 * @param template The compiled template generated by compileSvg()
 * @param replacements The replacments to apply
 * @returns The SVG with the replacements applied
 */
export function generateSvgForSetImage(
  template: CompiledSvgTemplate,
  replacements: Replacements
): string {
  if (!template) {
    return "";
  }

  // Render the SVG content with Handlebars replacements
  const renderedSvg = template(replacements);

  return `data:image/svg+xml;base64,${Buffer.from(renderedSvg, "utf8").toString(
    "base64"
  )}`;
}

/**
 * Checks to see if the specified path ends in ".svg"
 * @param svgPath The path to the SVG
 * @returns True if the path ends in "".svg"
 */
export function isSvg(svgPath: string | undefined) {
  return (
    svgPath !== undefined && path.extname(svgPath).toLowerCase() === ".svg"
  );
}

/**
 * Compiles an SVG to a Handlebars template. If the template isn't an
 * SVG returns undefined.
 * @param templatePath The path to the SVG
 * @returns The compiled SVG
 */
export function compileSvg(templatePath: string) {
  let svgContent: string;

  try {
    svgContent = fs.readFileSync(templatePath, "utf8");
  } catch (err) {
    console.error(err);
    return undefined;
  }

  return isSvg(templatePath) ? Handlebars.compile(svgContent) : undefined;
}
